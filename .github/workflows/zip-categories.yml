name: Auto Zip PDFs from Meeting Folders

on:
  push:
    paths:
      - 'acm/**'
      - 'fbos/**'
      - 'rac/**'
      - 'frc/**'
      - 'herc/**'
      - 'zips/**'

jobs:
  zip:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT }}

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y zip unzip

      - name: Create or update zips with validation
        run: |
          set -euo pipefail
          mkdir -p zips .checksums
          changed=false

          # Initialize array of directories we expect to process
          expected_dirs=("acm" "fbos" "rac" "frc" "herc")

          # Function to validate zip files
          validate_zip() {
            local zip_file=$1
            echo "Validating ZIP file: $zip_file"
            if ! unzip -tq "$zip_file"; then
              echo "❌ Invalid ZIP file detected, regenerating..."
              rm -f "$zip_file"
              return 1
            fi
            echo "✅ ZIP file validated successfully"
            return 0
          }

          # Process each directory
          for dir in "${expected_dirs[@]}"; do
            echo "Processing $dir..."
            hash_file=".checksums/$dir.sha"
            zip_file="zips/$dir.zip"
            needs_zip=false

            # Validate existing zip file if it exists
            if [ -f "$zip_file" ]; then
              if ! validate_zip "$zip_file"; then
                needs_zip=true
                changed=true
              fi
            else
              echo "Zip file missing for $dir"
              needs_zip=true
            fi

            # Check if directory exists
            if [ ! -d "$dir" ]; then
              echo "Directory $dir does not exist"
              # Remove zip and checksum if they exist
              [ -f "$zip_file" ] && rm -f "$zip_file" && changed=true
              [ -f "$hash_file" ] && rm -f "$hash_file" && changed=true
              continue
            fi

            # Compute current hash of PDFs
            current_hash=$(find "$dir" -type f -name "*.pdf" -print0 2>/dev/null | \
              xargs -0 stat --format '%n %s' 2>/dev/null | sha256sum | cut -d' ' -f1 || true)

            # Get previous hash if exists
            previous_hash=""
            if [ -f "$hash_file" ]; then
              previous_hash=$(cat "$hash_file")
            fi

            # Determine if we need to create/update zip
            if [ "$needs_zip" = true ] || [ "$current_hash" != "$previous_hash" ]; then
              echo "Update needed for $dir (missing zip: $needs_zip, hash changed: $([ "$current_hash" != "$previous_hash" ] && echo "yes" || echo "no")"

              pdf_count=$(find "$dir" -type f -name "*.pdf" | wc -l)
              
              if [ "$pdf_count" -gt 0 ]; then
                echo "Creating/updating zip with $pdf_count PDF(s) from $dir"
                
                # Create temp directory for zipping
                temp_dir=$(mktemp -d)
                trap 'rm -rf "$temp_dir"' EXIT
                
                # Copy PDFs to temp directory to ensure clean zip creation
                find "$dir" -type f -name "*.pdf" -exec cp {} "$temp_dir" \;
                
                # Create zip file with compression (-9 for maximum compression)
                (cd "$temp_dir" && zip -9 -r "$OLDPWD/$zip_file" .)
                
                # Verify the newly created zip
                if ! validate_zip "$zip_file"; then
                  echo "❌ Failed to create valid ZIP file"
                  exit 1
                fi
                
                ls -lh "$zip_file"
              else
                echo "No PDFs found in $dir, removing zip if exists"
                rm -f "$zip_file"
              fi

              echo "$current_hash" > "$hash_file"
              changed=true
            else
              echo "No changes detected for $dir"
            fi
          done

          if [ "$changed" = true ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git config core.autocrlf false
            
            # Synchronize with remote
            git fetch origin main
            if ! git merge --no-edit origin/main; then
              echo "Merge conflict detected, aborting..."
              git merge --abort
              exit 1
            fi

            git add .checksums zips
            if ! git diff --cached --quiet; then
              git commit -m "Auto-update: Regenerated ZIP files with validation"
              git remote set-url origin https://x-access-token:${{ secrets.PAT }}@github.com/${{ github.repository }}
              
              # Push with retry logic
              max_retries=3
              count=0
              until git push origin main; do
                count=$((count+1))
                if [ $count -ge $max_retries ]; then
                  echo "Push failed after $max_retries attempts"
                  exit 1
                fi
                echo "Push failed, retrying ($count/$max_retries)..."
                sleep 2
                git fetch origin main
                if ! git merge --no-edit origin/main; then
                  echo "Merge conflict detected during retry, aborting..."
                  git merge --abort
                  exit 1
                fi
              done
            else
              echo "No changes to commit despite detected changes (race condition?)"
            fi
          else
            echo "No ZIP updates needed."
          fi